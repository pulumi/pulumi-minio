// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as minio from "@pulumi/minio";
 *
 * const myBucketInAS3Bucket = new minio.S3Bucket("myBucketInAS3Bucket", {bucket: "my-bucket"});
 * const myBucketInBS3Bucket = new minio.S3Bucket("myBucketInBS3Bucket", {bucket: "my-bucket"}, {
 *     provider: minio.deployment_b,
 * });
 * const myBucketInAS3BucketVersioning = new minio.S3BucketVersioning("myBucketInAS3BucketVersioning", {
 *     bucket: myBucketInAS3Bucket.bucket,
 *     versioningConfiguration: {
 *         status: "Enabled",
 *     },
 * });
 * const myBucketInBS3BucketVersioning = new minio.S3BucketVersioning("myBucketInBS3BucketVersioning", {
 *     bucket: myBucketInBS3Bucket.bucket,
 *     versioningConfiguration: {
 *         status: "Enabled",
 *     },
 * }, {
 *     provider: minio.deployment_b,
 * });
 * const replicationPolicy = minio.getIamPolicyDocument({
 *     statements: [
 *         {
 *             sid: "ReadBuckets",
 *             effect: "Allow",
 *             resources: ["arn:aws:s3:::*"],
 *             actions: ["s3:ListBucket"],
 *         },
 *         {
 *             sid: "EnableReplicationOnBucket",
 *             effect: "Allow",
 *             resources: ["arn:aws:s3:::my-bucket"],
 *             actions: [
 *                 "s3:GetReplicationConfiguration",
 *                 "s3:ListBucket",
 *                 "s3:ListBucketMultipartUploads",
 *                 "s3:GetBucketLocation",
 *                 "s3:GetBucketVersioning",
 *                 "s3:GetBucketObjectLockConfiguration",
 *                 "s3:GetEncryptionConfiguration",
 *             ],
 *         },
 *         {
 *             sid: "EnableReplicatingDataIntoBucket",
 *             effect: "Allow",
 *             resources: ["arn:aws:s3:::my-bucket/*"],
 *             actions: [
 *                 "s3:GetReplicationConfiguration",
 *                 "s3:ReplicateTags",
 *                 "s3:AbortMultipartUpload",
 *                 "s3:GetObject",
 *                 "s3:GetObjectVersion",
 *                 "s3:GetObjectVersionTagging",
 *                 "s3:PutObject",
 *                 "s3:PutObjectRetention",
 *                 "s3:PutBucketObjectLockConfiguration",
 *                 "s3:PutObjectLegalHold",
 *                 "s3:DeleteObject",
 *                 "s3:ReplicateObject",
 *                 "s3:ReplicateDelete",
 *             ],
 *         },
 *     ],
 * });
 * // One-Way replication (A -> B)
 * const replicationInBIamPolicy = new minio.IamPolicy("replicationInBIamPolicy", {policy: replicationPolicy.then(replicationPolicy => replicationPolicy.json)}, {
 *     provider: minio.deployment_b,
 * });
 * const replicationInBIamUser = new minio.IamUser("replicationInBIamUser", {forceDestroy: true}, {
 *     provider: minio.deployment_b,
 * });
 * const replicationInBIamUserPolicyAttachment = new minio.IamUserPolicyAttachment("replicationInBIamUserPolicyAttachment", {
 *     userName: replicationInBIamUser.name,
 *     policyName: replicationInBIamPolicy.id,
 * }, {
 *     provider: minio.deployment_b,
 * });
 * const replicationInBIamServiceAccount = new minio.IamServiceAccount("replicationInBIamServiceAccount", {targetUser: replicationInBIamUser.name}, {
 *     provider: minio.deployment_b,
 *     dependsOn: [replicationInBIamUserPolicyAttachment],
 * });
 * const replicationInBS3BucketReplication = new minio.S3BucketReplication("replicationInBS3BucketReplication", {
 *     bucket: myBucketInAS3Bucket.bucket,
 *     rules: [{
 *         deleteReplication: true,
 *         deleteMarkerReplication: true,
 *         existingObjectReplication: true,
 *         metadataSync: true,
 *         target: {
 *             bucket: myBucketInBS3Bucket.bucket,
 *             secure: false,
 *             host: _var.minio_server_b,
 *             bandwidthLimt: "100M",
 *             accessKey: replicationInBIamServiceAccount.accessKey,
 *             secretKey: replicationInBIamServiceAccount.secretKey,
 *         },
 *     }],
 * }, {
 *     dependsOn: [
 *         myBucketInAS3BucketVersioning,
 *         myBucketInBS3BucketVersioning,
 *     ],
 * });
 * // Two-Way replication (A <-> B)
 * const replicationInAIamPolicy = new minio.IamPolicy("replicationInAIamPolicy", {policy: replicationPolicy.then(replicationPolicy => replicationPolicy.json)});
 * const replicationInAIamUser = new minio.IamUser("replicationInAIamUser", {forceDestroy: true});
 * const replicationInAIamUserPolicyAttachment = new minio.IamUserPolicyAttachment("replicationInAIamUserPolicyAttachment", {
 *     userName: replicationInAIamUser.name,
 *     policyName: replicationInAIamPolicy.id,
 * });
 * const replicationInAIamServiceAccount = new minio.IamServiceAccount("replicationInAIamServiceAccount", {targetUser: replicationInAIamUser.name}, {
 *     dependsOn: [replicationInBIamUserPolicyAttachment],
 * });
 * const replicationInAS3BucketReplication = new minio.S3BucketReplication("replicationInAS3BucketReplication", {
 *     bucket: myBucketInBS3Bucket.bucket,
 *     rules: [{
 *         deleteReplication: true,
 *         deleteMarkerReplication: true,
 *         existingObjectReplication: true,
 *         metadataSync: true,
 *         target: {
 *             bucket: myBucketInAS3Bucket.bucket,
 *             host: _var.minio_server_a,
 *             secure: false,
 *             bandwidthLimt: "100M",
 *             accessKey: replicationInAIamServiceAccount.accessKey,
 *             secretKey: replicationInAIamServiceAccount.secretKey,
 *         },
 *     }],
 * }, {
 *     provider: minio.deployment_b,
 *     dependsOn: [
 *         myBucketInAS3BucketVersioning,
 *         myBucketInBS3BucketVersioning,
 *     ],
 * });
 * ```
 */
export class S3BucketReplication extends pulumi.CustomResource {
    /**
     * Get an existing S3BucketReplication resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: S3BucketReplicationState, opts?: pulumi.CustomResourceOptions): S3BucketReplication {
        return new S3BucketReplication(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'minio:index/s3BucketReplication:S3BucketReplication';

    /**
     * Returns true if the given object is an instance of S3BucketReplication.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is S3BucketReplication {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === S3BucketReplication.__pulumiType;
    }

    /**
     * The name of the existing target bucket to replicate into
     */
    public readonly bucket!: pulumi.Output<string>;
    /**
     * Rule definitions
     */
    public readonly rules!: pulumi.Output<outputs.S3BucketReplicationRule[] | undefined>;

    /**
     * Create a S3BucketReplication resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: S3BucketReplicationArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: S3BucketReplicationArgs | S3BucketReplicationState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as S3BucketReplicationState | undefined;
            resourceInputs["bucket"] = state ? state.bucket : undefined;
            resourceInputs["rules"] = state ? state.rules : undefined;
        } else {
            const args = argsOrState as S3BucketReplicationArgs | undefined;
            if ((!args || args.bucket === undefined) && !opts.urn) {
                throw new Error("Missing required property 'bucket'");
            }
            resourceInputs["bucket"] = args ? args.bucket : undefined;
            resourceInputs["rules"] = args ? args.rules : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(S3BucketReplication.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering S3BucketReplication resources.
 */
export interface S3BucketReplicationState {
    /**
     * The name of the existing target bucket to replicate into
     */
    bucket?: pulumi.Input<string>;
    /**
     * Rule definitions
     */
    rules?: pulumi.Input<pulumi.Input<inputs.S3BucketReplicationRule>[]>;
}

/**
 * The set of arguments for constructing a S3BucketReplication resource.
 */
export interface S3BucketReplicationArgs {
    /**
     * The name of the existing target bucket to replicate into
     */
    bucket: pulumi.Input<string>;
    /**
     * Rule definitions
     */
    rules?: pulumi.Input<pulumi.Input<inputs.S3BucketReplicationRule>[]>;
}
