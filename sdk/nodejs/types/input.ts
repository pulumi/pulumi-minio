// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetIamPolicyDocumentStatement {
    actions?: string[];
    conditions?: inputs.GetIamPolicyDocumentStatementCondition[];
    effect?: string;
    principal?: string;
    resources?: string[];
    sid?: string;
}

export interface GetIamPolicyDocumentStatementArgs {
    actions?: pulumi.Input<pulumi.Input<string>[]>;
    conditions?: pulumi.Input<pulumi.Input<inputs.GetIamPolicyDocumentStatementConditionArgs>[]>;
    effect?: pulumi.Input<string>;
    principal?: pulumi.Input<string>;
    resources?: pulumi.Input<pulumi.Input<string>[]>;
    sid?: pulumi.Input<string>;
}

export interface GetIamPolicyDocumentStatementCondition {
    test: string;
    values: string[];
    variable: string;
}

export interface GetIamPolicyDocumentStatementConditionArgs {
    test: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
    variable: pulumi.Input<string>;
}

export interface IlmPolicyRule {
    expiration?: pulumi.Input<string>;
    filter?: pulumi.Input<string>;
    /**
     * The ID of this resource.
     */
    id: pulumi.Input<string>;
    noncurrentVersionExpirationDays?: pulumi.Input<number>;
    status?: pulumi.Input<string>;
    tags?: pulumi.Input<{[key: string]: any}>;
}

export interface S3BucketNotificationQueue {
    events: pulumi.Input<pulumi.Input<string>[]>;
    filterPrefix?: pulumi.Input<string>;
    filterSuffix?: pulumi.Input<string>;
    /**
     * The ID of this resource.
     */
    id?: pulumi.Input<string>;
    queueArn: pulumi.Input<string>;
}

export interface S3BucketReplicationRule {
    /**
     * Rule ARN genrated by MinIO
     */
    arn?: pulumi.Input<string>;
    /**
     * Whether or not to synchronise marker deletion
     */
    deleteMarkerReplication?: pulumi.Input<boolean>;
    /**
     * Whether or not to propagate deletion
     */
    deleteReplication?: pulumi.Input<boolean>;
    /**
     * Whether or not this rule is enabled
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Whether or not to synchronise object created prior the replication configuration
     */
    existingObjectReplication?: pulumi.Input<boolean>;
    /**
     * Rule ID generated by MinIO
     */
    id?: pulumi.Input<string>;
    /**
     * Whether or not to synchonise buckets and objects metadata (such as locks). This must be enabled to achieve a two-way replication
     */
    metadataSync?: pulumi.Input<boolean>;
    /**
     * Bucket prefix object must be in to be syncronised
     */
    prefix?: pulumi.Input<string>;
    /**
     * Rule priority. If omitted, the inverted index will be used as priority. This means that the first rule definition will have the higher priority
     */
    priority?: pulumi.Input<number>;
    /**
     * Tags which objects must have to be syncronised
     */
    tags?: pulumi.Input<{[key: string]: any}>;
    /**
     * Bucket prefix
     */
    target: pulumi.Input<inputs.S3BucketReplicationRuleTarget>;
}

export interface S3BucketReplicationRuleTarget {
    /**
     * Access key for the replication service account in the target MinIO
     */
    accessKey: pulumi.Input<string>;
    /**
     * Maximum bandwidth in byte per second that MinIO can used when syncronysing this target. Minimum is 100MB
     */
    bandwidthLimt?: pulumi.Input<string>;
    /**
     * The name of the existing target bucket to replicate into
     */
    bucket: pulumi.Input<string>;
    /**
     * Disable proxy for this target
     */
    disableProxy?: pulumi.Input<boolean>;
    /**
     * Period where the health of this target will be checked. This must be a valid duration, such as `5s` or `2m`
     */
    healthCheckPeriod?: pulumi.Input<string>;
    /**
     * The target host (pair IP/port or domain port). If port is omitted, HTTPS port (or HTTP if unsecure) will be used. This host must be reachable by the MinIO instance itself
     */
    host: pulumi.Input<string>;
    /**
     * Path of the Minio endpoint. This is usefull if MinIO API isn't served on at the root, e.g for `example.com/minio/`, the path would be `/minio/`
     */
    path?: pulumi.Input<string>;
    /**
     * Whether to use path-style or virtual-hosted-syle request to this target (https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html#path-style-access). `auto` allows MinIO to chose automatically the appropriate option (Recommened)`
     */
    pathStyle?: pulumi.Input<string>;
    /**
     * Region of the target MinIO. This will be used to generate the target ARN
     */
    region?: pulumi.Input<string>;
    /**
     * Secret key for the replication service account in the target MinIO. This is optional so it can be imported but prevent secret update
     */
    secretKey?: pulumi.Input<string>;
    secure?: pulumi.Input<boolean>;
    /**
     * The storage class to use for the object on this target
     */
    storageClass?: pulumi.Input<string>;
    /**
     * Use synchronous replication.
     */
    syncronous?: pulumi.Input<boolean>;
}

export interface S3BucketVersioningVersioningConfiguration {
    excludeFolders?: pulumi.Input<boolean>;
    excludedPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    status: pulumi.Input<string>;
}
