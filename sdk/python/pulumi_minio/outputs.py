# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'IlmPolicyRule',
    'S3BucketNotificationQueue',
    'S3BucketReplicationRule',
    'S3BucketReplicationRuleTarget',
    'S3BucketVersioningVersioningConfiguration',
    'GetIamPolicyDocumentStatementResult',
    'GetIamPolicyDocumentStatementConditionResult',
]

@pulumi.output_type
class IlmPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noncurrentVersionExpirationDays":
            suggest = "noncurrent_version_expiration_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IlmPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IlmPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IlmPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expiration: Optional[str] = None,
                 filter: Optional[str] = None,
                 noncurrent_version_expiration_days: Optional[int] = None,
                 status: Optional[str] = None,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if noncurrent_version_expiration_days is not None:
            pulumi.set(__self__, "noncurrent_version_expiration_days", noncurrent_version_expiration_days)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[str]:
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="noncurrentVersionExpirationDays")
    def noncurrent_version_expiration_days(self) -> Optional[int]:
        return pulumi.get(self, "noncurrent_version_expiration_days")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class S3BucketNotificationQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueArn":
            suggest = "queue_arn"
        elif key == "filterPrefix":
            suggest = "filter_prefix"
        elif key == "filterSuffix":
            suggest = "filter_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketNotificationQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketNotificationQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketNotificationQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Sequence[str],
                 queue_arn: str,
                 filter_prefix: Optional[str] = None,
                 filter_suffix: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "queue_arn", queue_arn)
        if filter_prefix is not None:
            pulumi.set(__self__, "filter_prefix", filter_prefix)
        if filter_suffix is not None:
            pulumi.set(__self__, "filter_suffix", filter_suffix)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def events(self) -> Sequence[str]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> str:
        return pulumi.get(self, "queue_arn")

    @property
    @pulumi.getter(name="filterPrefix")
    def filter_prefix(self) -> Optional[str]:
        return pulumi.get(self, "filter_prefix")

    @property
    @pulumi.getter(name="filterSuffix")
    def filter_suffix(self) -> Optional[str]:
        return pulumi.get(self, "filter_suffix")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class S3BucketReplicationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteMarkerReplication":
            suggest = "delete_marker_replication"
        elif key == "deleteReplication":
            suggest = "delete_replication"
        elif key == "existingObjectReplication":
            suggest = "existing_object_replication"
        elif key == "metadataSync":
            suggest = "metadata_sync"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketReplicationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketReplicationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketReplicationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: 'outputs.S3BucketReplicationRuleTarget',
                 arn: Optional[str] = None,
                 delete_marker_replication: Optional[bool] = None,
                 delete_replication: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 existing_object_replication: Optional[bool] = None,
                 id: Optional[str] = None,
                 metadata_sync: Optional[bool] = None,
                 prefix: Optional[str] = None,
                 priority: Optional[int] = None,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param 'S3BucketReplicationRuleTargetArgs' target: Bucket prefix
        :param str arn: Rule ARN genrated by MinIO
        :param bool delete_marker_replication: Whether or not to synchronise marker deletion
        :param bool delete_replication: Whether or not to propagate deletion
        :param bool enabled: Whether or not this rule is enabled
        :param bool existing_object_replication: Whether or not to synchronise object created prior the replication configuration
        :param str id: Rule ID generated by MinIO
        :param bool metadata_sync: Whether or not to synchonise buckets and objects metadata (such as locks). This must be enabled to achieve a two-way replication
        :param str prefix: Bucket prefix object must be in to be syncronised
        :param int priority: Rule priority. If omitted, the inverted index will be used as priority. This means that the first rule definition will have the higher priority
        :param Mapping[str, Any] tags: Tags which objects must have to be syncronised
        """
        pulumi.set(__self__, "target", target)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if delete_marker_replication is not None:
            pulumi.set(__self__, "delete_marker_replication", delete_marker_replication)
        if delete_replication is not None:
            pulumi.set(__self__, "delete_replication", delete_replication)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if existing_object_replication is not None:
            pulumi.set(__self__, "existing_object_replication", existing_object_replication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metadata_sync is not None:
            pulumi.set(__self__, "metadata_sync", metadata_sync)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.S3BucketReplicationRuleTarget':
        """
        Bucket prefix
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Rule ARN genrated by MinIO
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional[bool]:
        """
        Whether or not to synchronise marker deletion
        """
        return pulumi.get(self, "delete_marker_replication")

    @property
    @pulumi.getter(name="deleteReplication")
    def delete_replication(self) -> Optional[bool]:
        """
        Whether or not to propagate deletion
        """
        return pulumi.get(self, "delete_replication")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not this rule is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="existingObjectReplication")
    def existing_object_replication(self) -> Optional[bool]:
        """
        Whether or not to synchronise object created prior the replication configuration
        """
        return pulumi.get(self, "existing_object_replication")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Rule ID generated by MinIO
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="metadataSync")
    def metadata_sync(self) -> Optional[bool]:
        """
        Whether or not to synchonise buckets and objects metadata (such as locks). This must be enabled to achieve a two-way replication
        """
        return pulumi.get(self, "metadata_sync")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Bucket prefix object must be in to be syncronised
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Rule priority. If omitted, the inverted index will be used as priority. This means that the first rule definition will have the higher priority
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        Tags which objects must have to be syncronised
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class S3BucketReplicationRuleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bandwidthLimt":
            suggest = "bandwidth_limt"
        elif key == "disableProxy":
            suggest = "disable_proxy"
        elif key == "healthCheckPeriod":
            suggest = "health_check_period"
        elif key == "pathStyle":
            suggest = "path_style"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketReplicationRuleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketReplicationRuleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketReplicationRuleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 bucket: str,
                 host: str,
                 bandwidth_limt: Optional[str] = None,
                 disable_proxy: Optional[bool] = None,
                 health_check_period: Optional[str] = None,
                 path: Optional[str] = None,
                 path_style: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 secure: Optional[bool] = None,
                 storage_class: Optional[str] = None,
                 syncronous: Optional[bool] = None):
        """
        :param str access_key: Access key for the replication service account in the target MinIO
        :param str bucket: The name of the existing target bucket to replicate into
        :param str host: The target host (pair IP/port or domain port). If port is omitted, HTTPS port (or HTTP if unsecure) will be used. This host must be reachable by the MinIO instance itself
        :param str bandwidth_limt: Maximum bandwidth in byte per second that MinIO can used when syncronysing this target. Minimum is 100MB
        :param bool disable_proxy: Disable proxy for this target
        :param str health_check_period: Period where the health of this target will be checked. This must be a valid duration, such as `5s` or `2m`
        :param str path: Path of the Minio endpoint. This is usefull if MinIO API isn't served on at the root, e.g for `example.com/minio/`, the path would be `/minio/`
        :param str path_style: Whether to use path-style or virtual-hosted-syle request to this target (https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html#path-style-access). `auto` allows MinIO to chose automatically the appropriate option (Recommened)`
        :param str region: Region of the target MinIO. This will be used to generate the target ARN
        :param str secret_key: Secret key for the replication service account in the target MinIO. This is optional so it can be imported but prevent secret update
        :param str storage_class: The storage class to use for the object on this target
        :param bool syncronous: Use synchronous replication.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "host", host)
        if bandwidth_limt is not None:
            pulumi.set(__self__, "bandwidth_limt", bandwidth_limt)
        if disable_proxy is not None:
            pulumi.set(__self__, "disable_proxy", disable_proxy)
        if health_check_period is not None:
            pulumi.set(__self__, "health_check_period", health_check_period)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if path_style is not None:
            pulumi.set(__self__, "path_style", path_style)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if syncronous is not None:
            pulumi.set(__self__, "syncronous", syncronous)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Access key for the replication service account in the target MinIO
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the existing target bucket to replicate into
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The target host (pair IP/port or domain port). If port is omitted, HTTPS port (or HTTP if unsecure) will be used. This host must be reachable by the MinIO instance itself
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="bandwidthLimt")
    def bandwidth_limt(self) -> Optional[str]:
        """
        Maximum bandwidth in byte per second that MinIO can used when syncronysing this target. Minimum is 100MB
        """
        return pulumi.get(self, "bandwidth_limt")

    @property
    @pulumi.getter(name="disableProxy")
    def disable_proxy(self) -> Optional[bool]:
        """
        Disable proxy for this target
        """
        return pulumi.get(self, "disable_proxy")

    @property
    @pulumi.getter(name="healthCheckPeriod")
    def health_check_period(self) -> Optional[str]:
        """
        Period where the health of this target will be checked. This must be a valid duration, such as `5s` or `2m`
        """
        return pulumi.get(self, "health_check_period")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the Minio endpoint. This is usefull if MinIO API isn't served on at the root, e.g for `example.com/minio/`, the path would be `/minio/`
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="pathStyle")
    def path_style(self) -> Optional[str]:
        """
        Whether to use path-style or virtual-hosted-syle request to this target (https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html#path-style-access). `auto` allows MinIO to chose automatically the appropriate option (Recommened)`
        """
        return pulumi.get(self, "path_style")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region of the target MinIO. This will be used to generate the target ARN
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for the replication service account in the target MinIO. This is optional so it can be imported but prevent secret update
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        return pulumi.get(self, "secure")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        The storage class to use for the object on this target
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter
    def syncronous(self) -> Optional[bool]:
        """
        Use synchronous replication.
        """
        return pulumi.get(self, "syncronous")


@pulumi.output_type
class S3BucketVersioningVersioningConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeFolders":
            suggest = "exclude_folders"
        elif key == "excludedPrefixes":
            suggest = "excluded_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketVersioningVersioningConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketVersioningVersioningConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketVersioningVersioningConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 exclude_folders: Optional[bool] = None,
                 excluded_prefixes: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "status", status)
        if exclude_folders is not None:
            pulumi.set(__self__, "exclude_folders", exclude_folders)
        if excluded_prefixes is not None:
            pulumi.set(__self__, "excluded_prefixes", excluded_prefixes)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="excludeFolders")
    def exclude_folders(self) -> Optional[bool]:
        return pulumi.get(self, "exclude_folders")

    @property
    @pulumi.getter(name="excludedPrefixes")
    def excluded_prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_prefixes")


@pulumi.output_type
class GetIamPolicyDocumentStatementResult(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None,
                 conditions: Optional[Sequence['outputs.GetIamPolicyDocumentStatementConditionResult']] = None,
                 effect: Optional[str] = None,
                 principal: Optional[str] = None,
                 resources: Optional[Sequence[str]] = None,
                 sid: Optional[str] = None):
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetIamPolicyDocumentStatementConditionResult']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def principal(self) -> Optional[str]:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def sid(self) -> Optional[str]:
        return pulumi.get(self, "sid")


@pulumi.output_type
class GetIamPolicyDocumentStatementConditionResult(dict):
    def __init__(__self__, *,
                 test: str,
                 values: Sequence[str],
                 variable: str):
        pulumi.set(__self__, "test", test)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variable", variable)

    @property
    @pulumi.getter
    def test(self) -> str:
        return pulumi.get(self, "test")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def variable(self) -> str:
        return pulumi.get(self, "variable")


